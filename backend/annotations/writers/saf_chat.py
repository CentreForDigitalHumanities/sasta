from collections import defaultdict
from typing import Dict, List

from analysis.models import AssessmentMethod, Transcript
from analysis.results.results import AllResults
from chamd.chat_reader import ChatLine, ChatTier
from convert.chat_reader import ChatDocument
from natsort import natsorted
from sastadev.sastatypes import ExactResultsDict


def _items_by_utt_word(exactresults: ExactResultsDict, items_mapping: Dict) -> Dict:
    # filter out empty
    results = {k: v for k, v in exactresults.items() if v}

    # create nested defaultdict: dictionary of dictionaries of lists
    out = defaultdict(lambda: defaultdict(list))

    for (qid, _), hits in results.items():
        for (utt_id, wordno) in hits:
            out[utt_id][wordno].append(items_mapping.get(qid))

    return out


def _find_doc_line(lines: List[ChatLine], uttno: int) -> ChatLine:
    # TODO: more efficient way to do this?
    # return next((x for x in lines if x.uttno == uttno), None)
    return lines[uttno - 1]


def find_doc_line_xsid(lines: List[ChatLine], xsid: int) -> ChatLine:
    for x in lines:
        line_xsid = x.tiers.get('xsid')
        if line_xsid and line_xsid.text == str(xsid):
            return x
    return None



def enrich_chat(transcript: Transcript,
                allresults: AllResults,
                method: AssessmentMethod) -> ChatDocument:
    doc = ChatDocument.from_chatfile(
        transcript.content.path, transcript.corpus.method_category)

    target_ids = transcript.target_ids

    # construct a mapping of uttno to uttid
    # because uttid is unknown to CHAT
    marked_utts = (x for x in transcript.utterances.all() if x.for_analysis)

    # create mapping of query_ids to items
    items_mapping = {q.query_id: q.item for q in method.queries.all()}

    results_by_word = _items_by_utt_word(
        allresults.exactresults, items_mapping)

    for utt_id, words in results_by_word.items():
        if target_ids:
            doc_line = find_doc_line_xsid(doc.lines, int(utt_id))
        else:
            doc_line = _find_doc_line(doc.lines, int(utt_id))

        utt_hits = []
        for w in natsorted(words.keys()):
            utt_hits.extend(words[w])

        annotation_str = ', '.join(utt_hits)
        doc_line.tiers['xsyn'] = ChatTier(id='xsyn', text=annotation_str)
        # id_headers = [h for h in doc.headers if h.line.startswith('@ID')]
        # last_id_header = max(id_headers, key=attrgetter('linestartno'))
        # doc.headers.append(ChatHeader(
        #     line=f'@Comment:\tAnnotations on %xsyn-tiers generated by SASTA, using {method.category.name}',
        #     linestartno=last_id_header.linestartno+1))

    return doc
